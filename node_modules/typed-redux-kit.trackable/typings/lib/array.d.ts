import { Trackable } from './trackable';
export declare type TrackableArray<V> = V[] & TrackableArrayClass<V>;
export declare const TrackableArray: <V>(iterable?: Iterable<V>) => TrackableArray<V>;
export declare class TrackableArrayClass<V> extends Trackable<TrackableArrayClass<V>> {
    private internalArray;
    readonly length: number;
    constructor(iterable?: Iterable<V>);
    [Symbol.iterator](): IterableIterator<[string, any]>;
    /**
     * Modifier
     */
    set(index: number, newValue: V): this;
    push(...newValues: V[]): number;
    pop(): V;
    unshift(...newValues: V[]): number;
    shift(): V;
    splice(start: number, deleteCount?: number, ...items: V[]): V[];
    copyWithin(target: number, start?: number, end?: number): this;
    fill(value: V, start?: number, end?: number): this;
    reverse(): this;
    sort(compare?: (a: V, b: V) => number): this;
    /**
     * Selectors
     */
    get(index: number, defaultValue?: V): V;
    slice(start?: number, end?: number): V[];
    concat(...arrays: Array<TrackableArray<V>>): V[];
    entries(): IterableIterator<[number, V]>;
    every(callback: (value: V, index: number, array: V[]) => boolean, thisArg?: any): boolean;
    filter(callback: (value: V, index: number, array: V[]) => any, thisArg?: any): V[];
    find(predicate: (this: void, value: V, index: number, obj: Array<V>) => boolean): V | undefined;
    findIndex(predicate: (this: void, value: V, index: number, obj: Array<V>) => boolean): number;
    includes(searchElement: V, fromIndex?: number): boolean;
    indexOf(searchElement: V, fromIndex?: number): number;
    join(seperator?: string): string;
    keys(): IterableIterator<number>;
    lastIndexOf(searchElement: V, fromIndex?: number): number;
    map<U>(callback: (value: V, index: number, array: V[]) => U, thisArg?: any): U[];
    reduce<U>(callback: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue?: U): U;
    reduceRight<U>(callback: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue?: U): U;
    some(callback: (value: V, index: number, array: V[]) => boolean, thisArg?: any): boolean;
    toLocaleString(): string;
    toString(): string;
    values(): IterableIterator<V>;
    /**
     * Trackable Specifics
     */
    onChildChange(child: any): void;
    clone(): TrackableArray<V>;
    toJS(shallow?: boolean): V[];
    private reserveArrayBufferOnDemand();
}
export default TrackableArray;
